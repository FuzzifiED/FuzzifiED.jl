# Core functions

## Configurations
```@docs
Confs
```
It can be generated by the following method.
```@docs
Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2))
```
The inverse look-back for a configuration can be done by 
```@docs
GetConfId(cfs :: Confs, cf :: Int64)
```

## Basis
```@docs
Basis
```
It can be generated by the following methods.
```@docs
Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64} ; cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any})
Basis(cfs :: Confs)
```
The look-back of the weight of a configuration in a state can be done by 
```@docs
GetConfWeight(bs :: Basis, st :: Vector, cf :: Int64)
```

## Term

```@docs
Term
```
The product of terms with a number, the sum and product of terms and the adjoint is defined
```@docs
*(fac :: Number, tms :: Vector{Term})
+(tms1 :: Vector{Term}, tms2 :: Vector{Term})
*(tms1 :: Vector{Term}, tms2 :: Vector{Term})
adjoint(tms :: Vector{Term})
```
The terms can be simplified by 
```@docs
NormalOrder(tm :: Term)
SimplifyTerms(tms :: Vector{Term})
```

## Operator

```@docs
Operator
```
It can be generated by the following methods.
```@docs
Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(op :: Operator, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})
```

## Sparse matrix

```@docs
OpMat{T}
```
It can be generated by the following methods.
```@docs
OpMat(op :: Operator ; type :: DataType = ComplexF64)
```
The lowest eigenstates of the sparse matrix can be calculated by 
```@docs
GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
```
Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. 
```julia
stf = Operator(bsd, bsf, [Term(1., [-1, -1])]) * std
```

The `OpMat` object can be converted into a full matrix or converted with the `SparseMatrixCSC` object in the `SparseArrays` package. This will allow, _e.g._, full diagonalisation using the linear algebra package of julia. 
```@docs
SparseMatrixCSCFromOpMat(mat :: OpMat)
MatrixFromOpMat(mat :: OpMat)
OpMat(matcsc :: SparseMatrixCSC)
```

## Entanglement

```@docs
StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number})
GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, qnu_s_lst :: Vector{Any}, qnz_s_lst :: Vector{Any} ; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ "QN" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any}, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2)))
```

## Miscellaneous

```@docs
SilentStd
```