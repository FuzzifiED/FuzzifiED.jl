# Core functions

## Global parameters

The following parameters globally defines how FuzzifiED works, _viz._ whether it outputs logs, how many threads it uses and where it reads its libraries. In general, you can keep it at default. 
```@docs
SilentStd
NumThreads
Libpath
ElementType
```

## Quantum numbers

FuzzifiED implements diagonal and off-diagonal quantum numbers. They are defined as
```@docs
QNDiag
QNOffd
```
The QNDiag can be added or multiplied by a number 
```@docs
+(qnd1 :: QNDiag, qnd2 :: QNDiag)
*(fac :: Int64, qnd :: QNDiag)
```
The QNOffd can be composed
```@docs
*(qnf1 :: QNOffd, qnf2 :: QNOffd)
```

## Configurations
```@docs
Confs
```
It can be generated from the QNDiags.
```@docs
Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)
```
The inverse look-back for a configuration can be done by 
```@docs
GetConfId(cfs :: Confs, cf :: Int64)
```

## Basis
```@docs
Basis
```
It can be generated by the following methods.
```@docs
Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th = NumThreads, disp_std = !SilentStd)
Basis(cfs :: Confs)
```
The look-back of the weight of a configuration in a state can be done by 
```@docs
GetConfWeight(bs :: Basis, st :: Vector, cf :: Int64)
```

## Term

```@docs
Term
```
The product of terms with a number, the sum and product of terms and the adjoint is defined
```@docs
*(fac :: Number, tms :: Vector{Term})
+(tms1 :: Vector{Term}, tms2 :: Vector{Term})
*(tms1 :: Vector{Term}, tms2 :: Vector{Term})
adjoint(tms :: Vector{Term})
```
The terms can be simplified by 
```@docs
NormalOrder(tm :: Term)
SimplifyTerms(tms :: Vector{Term})
```

## Operator

```@docs
Operator
```
It can be generated by the following methods.
```@docs
Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(op :: Operator, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})
```

## Sparse matrix

```@docs
OpMat{T}
```
It can be generated by the following methods.
```@docs
OpMat(op :: Operator ; type :: DataType = ElementType)
```
The lowest eigenstates of the sparse matrix can be calculated by 
```@docs
GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
```
Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. 
```julia
stf = Operator(bsd, bsf, [Term(1., [-1, -1])]) * std
```

The `OpMat` object can be converted into a full matrix or converted with the `SparseMatrixCSC` object in the `SparseArrays` package. This will allow, _e.g._, full diagonalisation using the linear algebra package of julia. 
```@docs
SparseMatrixCSCFromOpMat(mat :: OpMat)
MatrixFromOpMat(mat :: OpMat)
OpMat(matcsc :: SparseMatrixCSC)
```

## Entanglement

```@docs
StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number})
GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{Int64}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2)))
```