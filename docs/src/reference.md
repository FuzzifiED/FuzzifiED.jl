# Reference

## Core

### Configurations
```@docs
Confs
```
It can be generated by the following method.
```@docs
Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2))
```
The inverse look-back for a configuration can be done by 
```@docs
GetConfId(cfs :: Confs, cf :: Int64)
```

### Basis
```@docs
Basis
```
It can be generated by the following methods.
```@docs
Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any})
Basis(cfs :: Confs)
```
The look-back of the weight of a configuration in a state can be done by 
```@docs
GetConfWeight(bs :: Basis, st :: Vector, cf :: Int64)
```

### Term

```@docs
Term
```
The product of terms with a number, the sum and product of terms and the adjoint is defined
```@docs
*(fac :: Number, tms :: Vector{Term})
+(tms1 :: Vector{Term}, tms2 :: Vector{Term})
*(tms1 :: Vector{Term}, tms2 :: Vector{Term})
adjoint(tms :: Vector{Term})
```
The terms can be simplified by 
```@docs
NormalOrder(tm :: Term)
SimplifyTerms(tms :: Vector{Term})
```

### Operator

```@docs
Operator
```
It can be generated by the following methods.
```@docs
Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(op :: Operator, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})
```

### Sparse matrix

```@docs
OpMat{T}
```
It can be generated by the following methods.
```@docs
OpMat(op :: Operator ; type :: DataType = ComplexF64)
```
The lowest eigenstates of the sparse matrix can be calculated by 
```@docs
GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
```
Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. 
```julia
stf = Operator(bsd, bsf, [Term(1., [-1, -1])]) * std
```

The `OpMat` object can be converted with the `SparseMatrixCSC` object in the `SparseArrays` package. This will allow, _e.g._, full diagonalisation using the linear algebra package of julia. 
```@docs
SparseMatrixCSCFromOpMat(mat :: OpMat)
OpMat(matcsc :: SparseMatrixCSC)
```

## ITensors support

This package also supports convertion with the `Site` and `OpSum` objects from `ITensors` library and management of DMRG sweeping process. To use these functions, include
```julia
using ITensors
```
at the heading of the Julia script.

### Format conversion

The `Sites` objects in `ITensors` can be converted to a `Confs` object with the conserved quantities extracted. 
```@docs
ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN)
ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64})
```
Conversely, the  `Sites` objects in `ITensors` can also be generated from a set of diagonal quantum numbers 
```@docs
SitesFromQnu(; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ "QN" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)])
```
If the number of quantum numbers are too many, it can be truncated by 
```@docs
TruncateQnu(; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ "QN" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], trunc_lth :: Int64 = 3, trunc_wt :: Vector{Int64} = [ 2 ^ (i - trunc_lth) for i = trunc_lth : length(qnu_o)]) 
```

The `OpSum` objects in `ITensors` can be converted with the collection of `Term`'s
```@docs
TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}})
OpSumFromTerms(tms :: Vector{Term})
```

### Easy sweep

This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. These functions require the package [`ITensorMPOConstruction`](https://github.com/ITensor/ITensorMPOConstruction.jl), which can be installed by 
```julia
julia> using Pkg; Pkg.add(url="https://github.com/ITensor/ITensorMPOConstruction.jl.git")
```

```@docs
EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String = "./", dim_list :: Vector{Int64} = [1000,2000,3000,4000,5000,6000], proj :: Vector{String} = String[], e_tol1 :: Float64 = 1E-6, e_tol :: Float64 = 1E-7, cutoff :: Vector{Float64} = [1E-9], maxdim0 :: Vector{Int64} = [10,20,50,100,200,500], noise0 :: Vector{Float64} = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], noise :: Vector{Float64} = [1E-6,2E-7,5E-8,1E-8,0], nsweeps :: Int64 = 10, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol1))
SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String = "./", cutoff :: Vector{Float64} = [1E-9], maxdim :: Vector{Int64} = [dim1], nsweeps :: Int64 = 10, noise :: Vector{Float64} = [1E-6,1E-7,0], proj :: Vector{String} = String[], e_tol :: Float64 = 1E-6, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol))
GetMpoSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String = "./", qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ "QN" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], old :: Bool = false)
GetMpo(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}}, sites :: Vector{<:Index} ; path :: String = "./", old :: Bool = false)
```

## Built-in models

```@docs
GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number})
GetL2Terms(nm :: Int64, nf :: Int64)
```

### General types of interactions

```@docs 
GetDenIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.0], mat_a :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf), mat_b :: Matrix{<:Number} = Matrix(mat_a'))
GetPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.0], mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number} = Matrix(mat_a'))
GetPolTerms(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf))
```

### Spherical observables

Fuzzified supports local observables that can be decomposed into angular components ``\Phi(\Omega)=\sum_{lm}\Phi_{lm}Y^{(s)}_{lm}``
```@docs
SphereObs
```
It can be initialised with the following methods 
```@docs
SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)
SphereObs(s2 :: Int64, l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Vector{Term}})
```
The following methods explicitly calculates and stores each component
```@docs
StoreComps!(obs :: SphereObs)
StoreComps(obs :: SphereObs)
```
The multiplication, addition, conjugate and Laplacian operation of an observable is supported 
```@docs
*(fac :: Number, obs :: SphereObs) 
+(obs1 :: SphereObs, obs2 :: SphereObs) 
adjoint(obs :: SphereObs)
*(obs1 :: SphereObs, obs2 :: SphereObs)
Laplacian(obs :: SphereObs)
```
The observables can be evaluated either at an angular component or at a real-space point.
```@docs
GetComponent(obs :: SphereObs, l :: Number, m :: Number)
GetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64)
```
Two types of operators, _viz._ electrons and density operators are built-in.
```@docs
Electron(nf :: Int64, nm :: Int64, f :: Int64)
Density(nf :: Int64, nm :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf))
```

### Ising model

```@docs
GetLzQnu(nm :: Int64, nf :: Int64)
GetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0)
GetLzZnQnu(nm :: Int64, nf :: Int64)
GetLzZnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, zn :: Int64 = 0)
GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0)
GetSnBasis(cfs :: Confs, nf :: Int64 ; qn_r :: Int64 = 0, perm :: Vector = [], qn_z :: Vector{<:Number} = Number[]) 
GetIsingIntTerms(nm :: Int64 ; ps_pot :: Vector = [1.])
GetXPolTerms(nm :: Int64)
GetZPolTerms(nm :: Int64)
```

### ``\mathrm{Sp}(N)`` model

```@docs
GetSpnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, sz :: Vector{Int64} = fill(0, div(nf, 2)))
GetSpnBasis(cfs :: Confs, nf :: Int64 ; qn_p :: Int64 = 0, qn_r :: Int64 = 0, qn_z :: Vector{Int64} = fill(0, div(nf, 2)), qn_x :: Vector{Int64} = fill(0, div(nf, 4)))
GetSpnPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.])
GetSpnC2Terms(nm :: Int64, nf :: Int64) 
```