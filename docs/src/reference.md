# Reference

## Basics 

### Configurations
```@docs
Confs
```
It can be generated by the following method.
```@docs
Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2))
```
The inverse look-back for a configuration can be done by 
```@docs
GetConfId(cfs :: Confs, cf :: Int64)
```

### Basis
```@docs
Basis
```
It can be generated by the following methods.
```@docs
Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any})
Basis(cfs :: Confs)
```
The look-back of the weight of a configuration in a state can be done by 
```@docs
GetConfWeight(bs :: Basis, st :: Vector, cf :: Int64)
```

### Term

```@docs
Term
```
The product of terms with a number, the sum and product of terms and the adjoint is defined
```@docs
*(fac :: Number, tms :: Vector{Term})
+(tms1 :: Vector{Term}, tms2 :: Vector{Term})
*(tms1 :: Vector{Term}, tms2 :: Vector{Term})
adjoint(tms :: Vector{Term})
```

### Operator

```@docs
Operator
```
It can be generated by the following methods.
```@docs
Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(op :: Operator, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})
```

### Sparse matrix

```@docs
OpMat{T}
```
It can be generated by the following methods.
```@docs
OpMat(op :: Operator ; type :: DataType = ComplexF64)
```
The lowest eigenstates of the sparse matrix can be calculated by 
```@docs
GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})
```
The `OpMat` object can be converted with the `SparseMatrixCSC` object in the `SparseArrays` package.
```@docs
SparseMatrixCSCFromOpMat(mat :: OpMat)
OpMat(matcsc :: SparseMatrixCSC)
```

## ITensors support

The `Sites` objects in `ITensors` can be converted to a `Confs` object with the conserved quantities extracted. 
```@docs
ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN)
ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64})
```
The `OpSum` objects in `ITensors` can be converted with the collection of `Term`'s
```@docs
TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}})
OpSumFromTerms(tms :: Vector{Term})
```

## Built-in models

```@docs
GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number})
GetL2Terms(nm :: Int64, nf :: Int64)
```

### Ising model

```@docs
GetIsingConfs(nm :: Int64, ne :: Int64 ; lz :: Float64 = 0.0)
GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0)
GetIsingIntTerms(nm :: Int64, ps_pot :: Vector)
GetXPolTerms(nm :: Int64)
GetZPolTerms(nm :: Int64)
```

### ``\mathrm{Sp}(N)`` model

```@docs
GetSpnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, sz :: Vector{Int64} = fill(0, div(nf, 2)))
GetSpnBasis(cfs :: Confs, nf :: Int64 ; qn_p :: Int64 = 0, qn_r :: Int64 = 0, qn_z :: Vector{Int64} = fill(0, div(nf, 2)), qn_x :: Vector{Int64} = fill(0, div(nf, 4)))
GetIdDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector)
GetSpnPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector)
GetSpnC2Terms(nm :: Int64, nf :: Int64) 
```