# Fuzzifino

Fuzzifino is a module for exact diagonalisation (ED) calculation on the fuzzy sphere for systems with both bosons and fermions. The usage is similar to FuzzifiED, with new types `SQNDiag`, `SQNOffd`, `SConf`, `SBasis`, `STerm` and `SOperator` defined. To use the module, include also at the start of your Julia script
```julia
using FuzzifiED.Fuzzifino
```

## Core functions

### Environment parameter

```@docs
FuzzifiED.Fuzzifino.Libpathino
```

### Quantum numbers

The diagonal and off-diagonal quantum numbers are implemented as
```@docs
SQNDiag
SQNOffd
```
The SQNs can be converted from the fermionic QNs by setting the bosonic part to identity. 
```@docs
SQNDiag(qnd :: QNDiag, nob :: Int64)
SQNOffd(qnf :: QNOffd, nob :: Int64)
```
Several operations of the SQNs are supported.
```@docs
*(fac :: Int64, qnd :: SQNDiag)
+(qnd1 :: SQNDiag, qnd2 :: SQNDiag)
*(qnf1 :: SQNOffd, qnf2 :: SQNOffd)
PadSQNDiag
PadSQNOffd
```

### Configurations
```@docs
SConfs
```
It can be generated from the QNDiags.
```@docs
SConfs(nof :: Int64, nob :: Int64, nebm :: Int64, secd :: Vector{Int64}, qnd :: Vector{SQNDiag} ; num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)
```

### Basis
```@docs
SBasis
```
It can be generated by the following methods.
```@docs
SBasis(cfs :: SConfs, secf :: Vector{<:Number}, qnf :: Vector{SQNOffd} ; num_th = NumThreads, disp_std = !SilentStd)
SBasis(cfs :: SConfs)
```

### Term

```@docs
STerm
STerms
```
The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined
```@docs
*(fac :: Number, tms :: STerms)
+(tms1 :: STerms, tms2 :: STerms)
*(tms1 :: STerms, tms2 :: STerms)
adjoint(tms :: STerms)
```
The terms can be simplified and manipulated by 
```@docs
NormalOrder(tm :: STerm)
SimplifyTerms(tms :: STerms)
RemoveOrbs(tms :: STerms, o_rm :: Vector{Int64})
RelabelOrbs(tms :: STerms, dict_o :: Dict{Int64, Int64})
PadSTerms
```

### Operator

```@docs
SOperator
```
It can be generated by the following methods.
```@docs
SOperator(bsd :: SBasis, bsf :: SBasis, terms :: STerms ; red_q :: Int64 = 0, sym_q :: Int64 = 0)
```
The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by
```@docs
*(op :: SOperator, st_d :: Vector{ComplexF64} ; num_th = NumThreads, disp_std = !SilentStd)
*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: SOperator, st_d :: Vector{ComplexF64} ; num_th = NumThreads, disp_std = !SilentStd)
```

### Sparse matrix

The OpMat can be generated from `SOperator` by the following methods.
```@docs
OpMat(op :: SOperator)
```
After the generation of sparse matrix, the diagonalisation can be condicted with FuzzifiED. 

### Entanglement

```@docs
StateDecompMat(st::Vector{<:Number}, bs0::SBasis, bsa::SBasis, bsb::SBasis, amp_ofa::Vector{<:Number}, amp_oba::Vector{<:Number}, amp_ofb::Vector{<:Number}, amp_obb::Vector{<:Number})
GetEntSpec(st::Vector{<:Number}, bs0::SBasis, secd_lst::Vector{Vector{Vector{Int64}}}, secf_lst::Union{Vector{Vector{Vector{ComplexF64}}}, Vector{Vector{Vector{Float64}}}, Vector{Vector{Vector{Int64}}}}; qnd_a, qnd_b, qnf_a, qnf_b, amp_ofa, amp_oba, amp_ofb, amp_obb, disp_std)
```

### Transformation

```@docs
STransf
STransf(bsd :: SBasis, bsf :: SBasis, qnf :: SQNOffd)
*(trs :: STransf, st_d :: Vector{ComplexF64} ; num_th = NumThreads)
```

## Models

Several quantum numbers and operator terms for the pure bosonic models are built-in.

```@docs
GetNeSQNDiag
GetBosonLz2SQNDiag
GetBosonFlavSQNDiag
GetBosonFlavPermSQNOffd
GetBosonRotySQNOffd
GetBosonDenIntSTerms
GetBosonPairIntSTerms
GetBosonPolSTerms
GetBosonLpLzSTerms
GetL2STerms(tms_lzlp :: Tuple{STerms, STerms})
GetBosonC2STerms
```
The types `SSphereObs` and `SAngModes` are similarly defined as their fermionic counterparts
```@docs
SSphereObs
SAngModes
```

## Related examples

* [`ising_frac_boson.jl`](https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_frac_boson.jl) calculates the spectrum of 3d Ising model on fuzzy sphere for bosons at fractional filling ``Î½ = 1/2``. This example reproduces Figure 12a,b in [Voinea 2024](@ref Voinea2024).