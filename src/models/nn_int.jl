
"""
    function GetIsingQnu(nm :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}

returns the diagonal quantum numbers, _i.e._, particle number ``N_e`` and angular momentum ``L_z``. 

# Arguments 

- `nm :: Int64` is the number of orbitals ; 
- `nf :: Int64` is the number of flavours ; 

# Output

A named tuple with three elements that can be directly fed into [`SitesFromQnu`](@ref)

- `qnu_o :: Vector{Vector{Int64}}` stores the charge of each orbital under each conserved quantity. See [`Confs`](@ref Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2), modul :: Vector{Int64} = fill(1, length(qnu_s)))) for detail.
- `qnu_name :: Vector{String}` stores the name of each quantum number.
- `modul :: Vector{Int64}` stores the modulus of each quantum number, 1 if no modulus. 

"""
function GetLzQnu(nm :: Int64, nf :: Int64)
    no = nf * nm
    qnu_o = []
    push!(qnu_o, fill(1, no)) 
    push!(qnu_o, [ div(o - 1, nf) for o = 1 : no ]) 
    qnu_name = ["N_e", "L_z"]
    modul = [1, 1]
    return (qnu_o = qnu_o, qnu_name = qnu_name, modul = modul)
end


"""
    function GetLzConfs(nm :: Int64 ; ne :: Int64 = 0, lz :: Float64) :: Confs

Return the configurations with conserved particle number ``N_e`` and angular momentum ``L_z``.
        
# Arguments

- `nm :: Int64` is the number of orbitals ``2s+1``.
- `nf :: Int64` is the number of flavours ; 
- `ne :: Int64` is the number of electrons.
- `lz :: Float64` is the angular momentum. Facultive, 0 by default. 
"""
function GetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0)
    no = nf * nm
    s = .5 * (nm - 1)
    qnu_s = Int64[ne, ne * s + lz]
    qnu = GetLzQnu(nm, nf)
    # Generate the configurations and print the number
    return Confs(no, qnu_s, qnu.qnu_o)
end


"""
    function GetZ3Basis(cfs :: Confs ; qn_z3 :: Number = 0, qn_z2 :: Int64 = 0, qn_r = 0) :: Basis

Return the basis with conserved flavour symmetry ``\\mathbb{Z}_3\\rtimes\\mathbb{Z}_2`` and ``\\pi``-rotation along ``y``-axis ``\\mathscr{R}`` from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. 

# Arguments

- `cfs :: Confs` is the configurations generated by [`GetIsingConfs`](@ref)
- `qn_p :: Int64` is quantum number for parity transformation. Facultive, 0 by default.
- `qn_z3 :: Number` is the quantum number for ``\\mathbb{Z}_3``-flavour transformation. Takes value from ``0,1,\\omega,\\omega^\\*``. Facultive, 0 by default.
- `qn_z2 :: Int64` is the quantum number for ``\\mathbb{Z}_3``-flavour transformation. Takes value from ``0,\\pm 1``. Facultive, 0 by default.
- `qn_r :: Int64` is the quantum number for  ``\\pi`` rotation along ``y``-axis compared with the ground state. Facultive, 0 by default.
"""
function GetS3Basis(cfs :: Confs ; qn_z3 :: Number = 0, qn_z2 :: Int64 = 0, qn_r = 0)
    no = cfs.no
    nf = 3
    nm = no รท nf
    qn_r1 = qn_r
    if (nm % 4 >= 2) qn_r1 = -qn_r end
    cyc = Vector{Int64}(undef, 0)
    qnz_s = Vector{ComplexF64}(undef, 0)
    perm_o = []
    ph_o = []
    fac_o = []
    if qn_z3 != 0
        push!(perm_o, [begin 
                f1 = mod(o - 1, nf)
                o + (f1 == 0 ? 2 : -1)
            end for o = 1 : no])
        push!(ph_o, fill(0, no))
        push!(fac_o, fill(ComplexF64(1), no))
        push!(qnz_s, qn_z3)
        push!(cyc, 3)
    end
    if qn_z2 != 0
        push!(perm_o, [begin 
                f1 = mod(o - 1, nf)
                o + (f1 == 0 ? 1 : (f1 == 1 ? -1 : 0))
            end for o = 1 : no])
        push!(ph_o, fill(0, no))
        push!(fac_o, fill(ComplexF64(1), no))
        push!(qnz_s, qn_z2)
        push!(cyc, 2)
    end
    if qn_r != 0
        push!(perm_o, [begin 
                f1 = mod(o - 1, nf) ; m1 = div(o - 1, nf)
                1 + f1 + nf * (nm - 1 - m1)
            end for o = 1 : no])
        push!(ph_o, fill(0, no)) 
        push!(fac_o, fill(ComplexF64(1), no)) 
        push!(qnz_s, qn_r1)
        push!(cyc, 2)
    end
    # Generate the basis and print the dimension
    return Basis(cfs, qnz_s, cyc, perm_o, ph_o, fac_o)
end


"""
    GetDenIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number}) :: Vector{Term}

Return the normal-ordered density-density term in the Hamiltonian 
```math 
\\sum_{\\{m_i,f_i\\}}U_{m_1m_2m_3m_4}M^A_{f_1f_4}M^B_{f_2f_3}c^{\\dagger}_{m_1f_1}c^{\\dagger}_{m_2f_2}c_{m_3f_3}c_{m_4f_4}
```

# Arguments 

- `nm :: Int64` is the number of orbitals.
- `nf :: Int64` is the number of flavours.
- `ps_pot :: Vector{<:Number}` is a list of numbers specifying the pseudopotentials for the interacting matrix ``U_{m_1m_2m_3m_4}``. Facultive, `[1.0]` by default.
- `mat_a :: Matrix{<:Number}` is a `nf`\\*`nf` matrix specifying ``M^A_{ff'}``. Facultive, ``I_{N_f}`` by default. 
- `mat_b :: Matrix{<:Number}` is a `nf`\\*`nf` matrix specifying ``M^B_{ff'}``. Facultive, the Hermitian conjugate of `mat_a` by default. 

"""
function GetDenIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.0], mat_a :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf), mat_b :: Matrix{<:Number} = Matrix(mat_a'))
    no = nm * nf
    int_el = GetIntMatrix(nm, ps_pot)
    tms = Vector{Term}(undef, 0)
    # Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3
    for o1 = 1 : no
        m1 = div(o1 - 1, nf) + 1
        f1 = mod(o1 - 1, nf) + 1
        for o2 = 1 : no 
            m2 = div(o2 - 1, nf) + 1
            f2 = mod(o2 - 1, nf) + 1
            if (o1 == o2) continue end
            # if (f1 < f2) continue end # f1 >= f2
            # if (f1 == f2 && m1 <= m2) continue end 
            for o3 = 1 : no
                m3 = div(o3 - 1, nf) + 1
                f3 = mod(o3 - 1, nf) + 1
                if (abs(mat_b[f2, f3]) < 1E-13) continue end 
                m4 = m1 + m2 - m3 
                if (m4 <= 0 || m4 > nm) continue end
                for f4 = 1 : nf 
                    if (abs(mat_a[f1, f4]) < 1E-13) continue end
                    o4 = (m4 - 1) * nf + f4
                    if (o3 == o4) continue end
                    val = mat_a[f1, f4] * mat_b[f2, f3] * int_el[m1, m2, m3]
                    if (abs(val) < 1E-15) continue end 
                    push!(tms, Term(val, [1, o1, 1, o2, 0, o3, 0, o4]))
                end
            end
        end
    end
    return tms
end

"""
    GetPolTerms(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf)) :: Vector{Term}

Return the polarisation term in the Hamiltonian 
```math 
\\sum_{mff'}c^{\\dagger}_{mf}M_{ff'}c_{mf'}
```

# Arguments 

- `nm :: Int64` is the number of orbitals ;
- `nf :: Int64` is the number of flavours ; 
- `mat :: Matrix{<:Number}` is a `nf`\\*`nf` matrix specifying ``M_{ff'}``. Facultive, ``I_{N_f}`` by default. 

"""
function GetPolTerms(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf))
    no = nm * nf
    tms = Vector{Term}(undef, 0)
    for o1 = 1 : no
        m1 = div(o1 - 1, nf) + 1
        f1 = mod(o1 - 1, nf) + 1
        for f2 = 1 : nf 
            if abs(mat[f1, f2]) < 1E-13 continue end
            o2 = (m1 - 1) * nf + f2
            push!(tms, Term(mat[f1, f2], [1, o1, 0, o2]))
        end
    end
    return tms
end