""" 
    function GetIsingQnu(nm :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}

returns the diagonal quantum numbers, _i.e._, particle number ``N_e`` and angular momentum ``L_z``, of the fuzzy sphere Ising model. 

# Arguments 

- `nm :: Int64` is the number of orbitals ; 

# Output

A named tuple with three elements that can be directly fed into [`SitesFromQN`](@ref)

- `qnu_o :: Vector{Vector{Int64}}` stores the charge of each orbital under each conserved quantity. See [`Confs`](@ref Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2), modul :: Vector{Int64} = fill(1, length(qnu_s)))) for detail.
- `qnu_name :: Vector{String}` stores the name of each quantum number.
- `modul :: Vector{Int64}` stores the modulus of each quantum number, 1 if no modulus. 

"""
function GetIsingQnu(nm :: Int64)
    nf = 2
    no = nf * nm
    qnu_o = []
    push!(qnu_o, fill(1, no)) 
    push!(qnu_o, [ div(o - 1, nf) for o = 1 : no ]) 
    qnu_name = ["N_e", "L_z"]
    modul = [1, 1]
    return (qnu_o = qnu_o, qnu_name = qnu_name, modul = modul)
end

"""
    function GetIsingConfs(nm :: Int64 ; ne :: Int64 = 0, lz :: Float64) :: Confs

Return the configurations with conserved particle number ``N_e`` and angular momentum ``L_z``.
        
# Arguments

- `nm :: Int64` is the number of orbitals ``2s+1``.
- `ne :: Int64` is the number of electrons.
- `lz :: Float64` is the angular momentum. Facultive, 0 by default. 
"""
function GetIsingConfs(nm :: Int64, ne :: Int64 ; lz :: Float64 = 0.0)
    s = .5 * (nm - 1)
    qnu_s = Int64[ne, ne * s + lz]
    qnu = GetIsingQnu(nm)
    # Generate the configurations and print the number
    return Confs(no, qnu_s, qnu.qnu_o)
end

"""
    function GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0) :: Basis

Return the basis with conserved parity ``\\mathscr{P}``, flavour symmetry ``\\mathscr{Z}`` and ``\\pi``-rotation along ``y``-axis ``\\mathscr{R}`` from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. 

# Arguments

- `cfs :: Confs` is the configurations generated by [`GetIsingConfs`](@ref)
- `qn_p :: Int64` is quantum number for parity transformation. Facultive, 0 by default.
- `qn_z :: Int64` is the particle quantum number for ``\\mathbb{Z}_2``-flavour transformation. Facultive, 0 by default.
- `qn_r :: Int64` is the quantum number for  ``\\pi`` rotation along ``y``-axis compared with the ground state. Facultive, 0 by default.
"""
function GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0)
    no = cfs.no
    qn_r1 = qn_r
    if (mod(no, 8) >= 4) qn_r1 = -qn_r end
    cyc = [ 2, 2, 2 ] # Input three Z_2 symmetries 
    qnz_s = ComplexF64[ qn_p, qn_z, qn_r ] # Quantum numbers are all positive 
    # Initialise the vectors
    perm_o = []
    ph_o = []
    fac_o = []
    # Record the parity
    push!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) 
    push!(ph_o, fill(1, no))
    push!(fac_o, [ isodd(o) ? -1 : 1 for o = 1 : no])
    # Record the flavour symmetry
    push!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no])
    push!(ph_o, fill(0, no))
    push!(fac_o, fill(ComplexF64(1), no))
    # Record the pi-rotation
    push!(perm_o, [ isodd(o) ? no - o : no + 2 - o for o = 1 : no])
    push!(ph_o, fill(0, no)) 
    push!(fac_o, fill(ComplexF64(1), no)) 
    # Generate the basis and print the dimension
    return Basis(cfs, qnz_s, cyc, perm_o, ph_o, fac_o)
end

"""
    function GetIsingIntTerms(nm :: Int64, ps_pot :: Vector) :: Vector{Term}

Returns the terms for the ising interaction 

```math
\\sum_{m_1m_2m_3m_4}2U_{m_1m_2m_3m_4}c^{\\dagger}_{m_1\\uparrow}c^{\\dagger}_{m_2\\downarrow}c_{m_3\\downarrow}c_{m_4\\uparrow}
```

from the pseudopotentials. 

# Arguments 

- `nm :: Int64` is the number of orbitals ``2s+1``.
- `ps_pot :: Vector{Number}` is the pseudopotential of Ising interaction.
"""
function GetIsingIntTerms(nm :: Int64, ps_pot :: Vector)
    nf = 2
    no = nm * 2
    int_el = GetIntMatrix(nm, ps_pot)
    tms_ising = Vector{Term}(undef, 0)
    # Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3
    for m1 = 1 : nm
        f1 = 0
        o1 = (m1 - 1) * nf + f1 + 1
        for m2 = 1 : nm
            f2 = 1
            o2 = (m2 - 1) * nf + f2 + 1
            for m3 = 1 : nm
                f3 = 1
                o3 = (m3 - 1) * nf + f3 + 1
                m4 = m1 + m2 - m3 
                if (m4 <= 0 || m4 > nm) continue end
                f4 = 0
                o4 = (m4 - 1) * nf + f4 + 1
                push!(tms_ising, Term(int_el[m1, m2, m3] * 2., [1, o1, 1, o2, 0, o3, 0, o4]))
            end
        end
    end
    return tms_ising
end

"""
    function GetXPolTerms(nm :: Int64)

Returns the terms for the density operator ``n^x_{l=0,m=0}``

# Arguments 

- `nm :: Int64` is the number of orbitals.
"""
function GetXPolTerms(nm :: Int64)
    return [ Term(1, [1, isodd(i) ? i + 1 : i - 1, 0, i]) for i = 1 : 2 * nm]
end

"""
    function GetZPolTerms(nm :: Int64)

Returns the terms for the density operator ``n^z_{l=0,m=0}``

# Arguments 

- `nm :: Int64` is the number of orbitals.
"""
function GetZPolTerms(nm :: Int64)
    return [ Term(isodd(i) ? 1 : -1, [1, i, 0, i]) for i = 1 : 2 * nm]
end