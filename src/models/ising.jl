"""
    function GenerateIsingConfs(nm :: Int64 ; ne :: Int64 = 0, lz :: Float64 = 0) :: Confs

# Arguments

- `nm :: Int64` is the number of orbitals ``2s+1``.
- `ne :: Int64` is the number of orbitals compared with half filling. Facultive, 0 by default.
- `lz :: Int64` is the angular momentum. Facultive, 0 by default. 
"""
function GenerateIsingConfs(nm :: Int64 ; ne :: Int64 = 0, lz :: Float64 = 0.0)
    nf = 2
    no = nf * nm
    s = .5 * (nm - 1)
    qnu_s = Vector{Int64}(undef, 0)
    qnu_o = []
    # Record the number of electrons
    push!(qnu_o, fill(1, no)) 
    push!(qnu_s, nm + ne) 
    # Record the angular momentum
    push!(qnu_o, [ div(o - 1, nf) for o = 1 : no ]) 
    push!(qnu_s, Int((nm + ne) * s + lz))
    # Generate the configurations and print the number
    return Confs(no, qnu_s, qnu_o)
end

"""
    function GenerateIsingBasis(cfs :: Confs ; PH :: Int64 = 0, Ry :: Int64 = 0, Z2 :: Int64 = 0) :: Basis

# Arguments

- `cfs :: Confs` is the configurations generated by [`GenerateIsingConfs`](@ref)
- `PH :: Int64` is quantum number for particle-hole transformation. Facultive, 0 by default.
- `Ry :: Int64` is the quantum number for  ``\\pi`` rotation along ``y``-axis. Facultive, 0 by default.
- `Z2 :: Int64` is the particle quantum number for ``\\mathbb{Z}_2``-flavour transformation. Facultive, 0 by default.
"""
function GenerateIsingBasis(cfs :: Confs ; PH :: Int64 = 0, Z2 :: Int64 = 0, Ry :: Int64 = 0)
    no = cfs.no
    Ry1 = Ry
    if (mod(no, 8) >= 4) Ry1 = -Ry1 end
    cyc = [ 2, 2, 2 ] # Input three Z_2 symmetries 
    qnz_s = ComplexF64[ PH, Z2, Ry1 ] # Quantum numbers are all positive 
    # Initialise the vectors
    perm_o = []
    ph_o = []
    fac_o = []
    # Record the parity
    push!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) 
    push!(ph_o, fill(1, no))
    push!(fac_o, [ isodd(o) ? -1 : 1 for o = 1 : no])
    # Record the flavour symmetry
    push!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no])
    push!(ph_o, fill(0, no))
    push!(fac_o, fill(ComplexF64(1), no))
    # Record the pi-rotation
    push!(perm_o, [ isodd(o) ? no - o : no + 2 - o for o = 1 : no])
    push!(ph_o, fill(0, no)) 
    push!(fac_o, fill(ComplexF64(1), no)) 
    # Generate the basis and print the dimension
    return Basis(cfs, qnz_s, cyc, perm_o, ph_o, fac_o)
end

"""
    function GenerateIsingHamiltonianTerms(nm :: Int64 ; ps_pot :: Vector{Number} = Number[4.75, 1], fld_h :: Number = 3.16) :: Vector{Term}

# Arguments 

- `nm :: Int64` is the number of orbitals ``2s+1``.
- `ps_pot :: Vector{Number}` is the pseudopotential of Ising interaction.
- `fld_h :: Number` is the transverse field.
"""
function GetIsingIntTerms(nm :: Int64, ps_pot :: Vector)
    nf = 2
    no = nm * 2
    int_el = GetIntMatrix(nm, ps_pot)
    tms_ising = Vector{Term}(undef, 0)
    # Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3
    for m1 = 1 : nm
        f1 = 0
        o1 = (m1 - 1) * nf + f1 + 1
        for m2 = 1 : nm
            f2 = 1
            o2 = (m2 - 1) * nf + f2 + 1
            for m3 = 1 : nm
                f3 = 1
                o3 = (m3 - 1) * nf + f3 + 1
                m4 = m1 + m2 - m3 
                if (m4 <= 0 || m4 > nm) continue end
                f4 = 0
                o4 = (m4 - 1) * nf + f4 + 1
                push!(tms_ising, Term(int_el[m1, m2, m3] * 2., [1, o1, 1, o2, 0, o3, 0, o4]))
            end
        end
    end
    return tms_ising
end

"""
    function GetXPolTerms(nm :: Int64)

Returns the terms for the density operator ``n^x_{l=0,m=0}``

# Arguments 

- `nm :: Int64` is the number of orbitals.
"""
function GetXPolTerms(nm :: Int64)
    return [ Term(1, [1, isodd(i) ? i + 1 : i - 1, 0, i]) for i = 1 : 2 * nm]
end

"""
    function GetZPolTerms(nm :: Int64)

Returns the terms for the density operator ``n^z_{l=0,m=0}``

# Arguments 

- `nm :: Int64` is the number of orbitals.
"""
function GetZPolTerms(nm :: Int64)
    return [ Term(isodd(i) ? 1 : -1, [1, i, 0, i]) for i = 1 : 2 * nm]
end